# git SHA1 介绍

git 为每一个实体生成一个160位的散列值，通常使用40个字符长度的16进制字符串表示  
示例：0bb9011444ae6ccbf30fdbf8470eebde0007d398  

### 特性
该散列值 **对于给定的输入总是产生相同的输出** ，通常该算法也称为：摘要，这个特性非常重要，因为这样可以保证在文件内容不变的情况下，产生的 SAH1 的输出总是相同的。  
git 也正是利用该特性来快速定位某两次提交直接的差异，试想下在一个包含非常复杂目录结构的项目中，当你使用`git add`来暂存修改时，git 如何知道哪些文件是从上一个 commit 以来被修改的，通常的情况下你可能需要递归遍历所有的目录、子目录以及所有的文件来对比目录结构及文件内容是否发生了变化，这样效率是非常低的，而 git 可以通过给某个目录计算散列值，并转换成相应的 tree 实体，如果该目录的 tree 实体对应的 SHA1 和上一次提交对应的 tree 实体的 SHA1 值是相同的，则可以断定该目录及其所有的子目录及这些文件夹下面的文件内容都是没有被修改过（否则两次计算得到的 SHA1 就不会相等），git 正是通过这种方式来快速缩小两次提交之间的差异比对。  

### 散列碰撞
通常情况下你不需要担心该散列值会产生碰撞，对于 160 位数，你有 2<sup>160</sup> 或者大约 10<sup>48</sup> 种可能的 SHA1 散列值。这个数有多么巨大，你可以简单感受下，即使你雇一万亿人来每秒产生一万亿个新的唯一 blob 对象，持续一万亿年，你也只有 10<sup>43</sup> 个 blob 对象，所以你基本不用担心该散列值会产生碰撞，而且只有当不同的内容产生了相同的 SHA1 散列值才能称为碰撞。  

### git 基于内容的 SHA1
